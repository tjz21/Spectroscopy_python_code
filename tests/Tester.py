from os.path import *
from os import chdir
import numpy as np
import pickle
import io
import sys
from generate_spectra import main
from unittest import TestCase

def _update_file_data(file_data_container: dict, file, X):
    #   a string assumes that it is overriting the file
    if isinstance(file, str):
        file_data_container[file] = X
    #   FakeFile is only used for 2DES file writing (for now)
    elif isinstance(file, FakeFile):
        file_name = file.file_name
        if file_name not in file_data_container:
            file_data_container[file_name] = [X]
        else:
            file_data_container[file_name].append(X)
    else:
        raise ValueError('"file" must be a string ofr FakeFile object')

class FakeFile(io.StringIO):
    def __init__(self, file_name, initial_value: str = None, newline: str = None) -> None:
        super().__init__(initial_value, newline)
        self.file_name = file_name

class Tester():
    ### Controll Flags ###
    SAVE_RESULTS = False    #   save results and overwrite existing reference data
    HIDE_STDOUT = False      #   do not show stdout in colsole
    HIDE_WARNINGS = True    #   hide all warnings

    def __init__(self, input_file: str):
        '''
        Contains methods to analyze spectra tests. The class also routes all 
        np.savetxt to `io.StringIO()` so that tests do not creat actual output
        files, but instead keeps them in memory. 

        Parameters
        ----------
        input_file: str
            name of the input file with options to run MolSpecPy
        '''
        #   change directory to data filder
        self.data_dir = join(dirname(__file__), 'data')
        chdir(self.data_dir)

        #   override np.savetxt so we capture the raw data and prevent writing to disk
        self.file_data = {'test': []}
        self.ref_file_data = {}

        self.input_file = join(self.data_dir, input_file)
        self.output_file = io.StringIO()

    def run_molspecpy(self):

        #   override numpy savetxt
        def savetxt_new(file, X, **kwargs):
            _update_file_data(self.file_data, file, X)

        savetxt_orig = np.savetxt
        np.savetxt = savetxt_new
        
        if self.HIDE_STDOUT:
            old_stdout = sys.stdout
            with io.StringIO() as fake_file:
                sys.stdout = fake_file
                main([self.input_file], self.output_file)
                sys.stdout = old_stdout
        else:
            main([self.input_file], self.output_file)

        #   restore numpy savetxt
        np.savetxt = savetxt_orig

    def check_files(self, name: str):
        '''
            Load the reference data files, and check that references file names
            have also been generated by the test. If SAVE_RESULTS = True, then
            this method will also save the files to disk BEFORE checking. This
            is usefull for generating new unit tests.

            Parameters
            ----------
            name : str
                The name of the test that is to be loaded and checked
        '''

        # for file, data in self.file_data.items():
        #     #   strings should already be taken care of 
        #     #   through the np.savetxt override
        #     if isinstance(file, str):
        #         continue
        #     elif isinstance(file, FakeFile):
        #         self.file_data.pop(file)
        #         file.seek(0)
        #         self.file_data[file.file_name] = np.


        ref_file_loc = join('reference', name) + '.pkl'

        #   dump results, used to reset or update tests
        if self.SAVE_RESULTS:
            with open(ref_file_loc, 'wb') as file:
                pickle.dump(self.file_data, file)

        #   print created files
        for f in self.file_data:
            print("FILE: ", f)
        
        #   load reference data
        with open(ref_file_loc, 'rb') as file:
            self.ref_file_data = pickle.load(file)

        #   make sure all file names were produced by molspecpy
        for file_name in self.file_data:
            assert file_name in self.ref_file_data

    def compare_linear_spectra(self, test_case: TestCase, spectrum_name: str):
        '''
            Compares linear spectrum array information, like absorption and emission

            Parameters
            ----------
            test_case: TestCase
                the current TestCase object being run
            spectrum_name : str
                the suffix of the spectrum data file (i.e. 'MD_ensemble_spectrum.dat')
        '''
        
        #   grab data and make sure there is only one
        data = []
        ref_data = []
        for file, d in self.file_data.items():
            if spectrum_name in file:
                data.append(d)
                ref_data.append(self.ref_file_data[file])
        test_case.assertEqual(len(data), 1)

        data = data[0]
        ref_data = ref_data[0]

        #   make sure first and last energies are the same
        test_case.assertEqual(data[ 0, 0], ref_data[ 0, 0])
        test_case.assertEqual(data[-1, 0], ref_data[-1, 0])

        #   make sure intervals are the same at each end too
        places = 10
        dE_ref_first = ref_data[ 1, 0] - ref_data[ 0, 0]
        dE_ref_last  = ref_data[-1, 0] - ref_data[-2, 0]
        dE_first = data[ 1, 0] - data[ 0, 0]
        dE_last  = data[-1, 0] - data[-2, 0]
        test_case.assertAlmostEqual(dE_ref_first,    dE_first,       places=places)
        test_case.assertAlmostEqual(dE_ref_last,     dE_last,        places=places)
        test_case.assertAlmostEqual(dE_ref_first,    dE_ref_last,    places=places)
        test_case.assertAlmostEqual(dE_first,        dE_last,        places=places)

        #   no NaNs are allowed
        test_case.assertEqual(np.sum(np.isnan(data)), 0)

        #   now check actual spectrum data itself
        np.testing.assert_array_almost_equal(data, ref_data, places, verbose=True)

    def compare_spectra_2d(self, test_case: TestCase, spectrum_name: str):
        '''
            Compares 2D spectrum array information, either 2DES w1/w3 data or transient absorption

            Parameters
            ----------
            test_case: TestCase
                the current TestCase object being run
            spectrum_name : str
                the suffix of the spectrum data file (i.e. 'MD_ensemble_spectrum.dat')
        '''
        
        #   grab data and make sure there is only one
        tst_file_data = []
        ref_file_data = []
        for file, d in self.file_data.items():
            if spectrum_name in file:
                tst_file_data.append(d)
                ref_file_data.append(self.ref_file_data[file])
        test_case.assertEqual(len(tst_file_data), 1)

        tst_data = np.array(tst_file_data[0], dtype=float)
        ref_data = np.array(ref_file_data[0], dtype=float)

        #   compare dimensions of data
        dim_tst = tst_data.shape
        dim_ref = ref_data.shape
        test_case.assertEqual(len(dim_tst), 3)
        test_case.assertEqual(len(dim_tst), len(dim_ref))
        test_case.assertEqual(dim_tst[2], 3)
        test_case.assertEqual(dim_tst[0], dim_ref[0])
        test_case.assertEqual(dim_tst[1], dim_ref[1])
        test_case.assertEqual(dim_tst[2], dim_ref[2])

        #   loop over each omega_1 value and check spectra as a function of omega_3
        places = 10
        for tst_data_i, ref_data_i in zip(tst_data, ref_data):
            #   first and last values should be equal
            for j in range(3):
                test_case.assertAlmostEqual(tst_data_i[0, j], ref_data_i[0, j], places=places)
                test_case.assertAlmostEqual(tst_data_i[-1, j], ref_data_i[-1, j], places=places)


            #   make sure first and and last intervals, in both x any y directions, also match
            test_case.assertAlmostEqual(tst_data_i[1, 0] - tst_data_i[0, 0], 
                                        ref_data_i[1, 0] - ref_data_i[0, 0], places=places)
            test_case.assertAlmostEqual(tst_data_i[0, 1] - tst_data_i[0, 0], 
                                        ref_data_i[0, 1] - ref_data_i[0, 0], places=places)
            test_case.assertAlmostEqual(tst_data_i[-1, 0] - tst_data_i[-2, 0], 
                                        ref_data_i[-1, 0] - ref_data_i[-2, 0], places=places)
            test_case.assertAlmostEqual(tst_data_i[0, -1] - tst_data_i[0, -2], 
                                        ref_data_i[0, -1] - ref_data_i[0, -2], places=places)

            #   no NaNs are allowed
            test_case.assertEqual(np.sum(np.isnan(tst_data_i)), 0)

            #   now check actual spectrum data itself
            np.testing.assert_array_almost_equal(tst_data_i, ref_data_i, places, verbose=True)

